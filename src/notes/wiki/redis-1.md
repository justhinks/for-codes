## redis 规范

1. key不再使用md5字符串截取，统一 使用明文 。（线上运行的不强制修改）
2. 统一以 : 作为多级分隔，如 spot:markets 。
3. 所有key必须明确对应的业务，比如现货以 spot: 开头，合约以 futures: 开头，不要以开发程序的名字做前缀。
  1. 例：
  2. key: apim:u:1
  3. value: {...}
4. key 不能太长也不能太短，键名越长越占资源，太短可读性太差。 key 的名称长度尽可能控制在 32 字节以内，过长的 key 可以通过使用缩略词等方式来简化。
5. 命名采用 camelCase 方式，区分大小写。
6. key 应该避免包含特殊字符，如空格、换行、单双引号等转义字符。
7. 过期时间设置 ，防止产生无效数据长期占用内存，如果存在同时设置大量缓存，过期时间可以在一个时间范围内，比如： 600+mt_rand(0，30)；
8. 数据类型，应根据具体数据类型选择redis的支持的结构，比如hash、set等，提高存储响应速度。
9. 是否压缩，对于过大的数据要进行压缩，一般超过10k的考虑再压缩。
  1. 错误：['aa', 'bb', 'cc'] → 压缩 → set ， 正确：['aa', 'bb', 'cc'] → set
  2. 错误：coinbd settings → set ， 正确：coinbd settings → 压缩 ->set
10. 对于某些场景从全局变量获取的value，不需要设置缓存，例如：coinbd 获取某个币种，此时value本身不大，再经过redis 本地网络 set、get，压缩、解压缩、encode、decode，产生不必要的资源使用，增加了服务的不确定性。
11. 使用 pipeline 批量查询，可以减少网络开销和提高查询效率，但不能滥用会导致占用更多的带宽和内存、CPU。
12. 使用 lua 执行多个命令原子操作。
13. 减少请求次数和数据大小 ，global redis瓶颈主要在网络传输和带宽，以及大key的阻塞。
  1. 错误示范：redis_exists → redis_del → redis_set （三次io），正确：redis_set
14. 大key问题 ，要考虑拆分成小key防止阻塞导致集群响应变慢，只获取需要的内容而不是全部，提高存储响应速度。
  1. 应拆尽拆
15. 热key问题 ，对于可能出现的热key要有一定的预估
  1. 考虑拆key
  2. 随机后缀，写多份
  3. 本地缓存
16. 无论是数据还是key，都可以通过 拆分更小的数据 来提升性能。
17. 禁止使用 keys 等O(N)复杂度的命令
18. 使用连接池